import { NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";

export async function GET() {
    try {
        const session = await auth();

        if (!session?.user?.id) {
            return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }

        // Fetch all achievements with generated content
        const achievements = await prisma.achievement.findMany({
            where: { userId: session.user.id },
            orderBy: { occurredAt: "desc" },
            include: {
                content: true,
            },
        });

        // Generate Markdown content
        let markdown = `# My Open Source Achievements\n\n`;
        markdown += `Generated by gitXflow on ${new Date().toLocaleDateString("en-US", {
            month: "long",
            day: "numeric",
            year: "numeric",
        })}\n\n`;
        markdown += `---\n\n`;

        // Stats section
        const totalScore = achievements.reduce((sum: number, a: any) => sum + a.score, 0);
        markdown += `## Summary\n\n`;
        markdown += `- **Total Achievements:** ${achievements.length}\n`;
        markdown += `- **Impact Score:** ${totalScore}\n`;
        markdown += `- **PRs Merged:** ${achievements.filter((a: any) => a.type === "pr_merged").length}\n\n`;
        markdown += `---\n\n`;

        // Achievements section
        markdown += `## Achievements\n\n`;

        for (const achievement of achievements) {
            markdown += `### ${achievement.title}\n\n`;
            markdown += `**Repository:** [${achievement.repoOwner}/${achievement.repoName}](${achievement.repoUrl})\n\n`;
            markdown += `**Type:** ${achievement.type.replace("_", " ")}\n\n`;
            markdown += `**Score:** ${achievement.score}\n\n`;
            markdown += `**Date:** ${new Date(achievement.occurredAt).toLocaleDateString()}\n\n`;

            if (achievement.description) {
                markdown += `**Description:** ${achievement.description}\n\n`;
            }

            // Add generated content
            const resumeContent = achievement.content.find(
                (c: any) => c.format === "resume_bullet"
            );
            if (resumeContent) {
                markdown += `**Resume Bullet:**\n\n`;
                markdown += `> ${resumeContent.content}\n\n`;
            }

            const linkedinContent = achievement.content.find(
                (c: any) => c.format === "linkedin_post"
            );
            if (linkedinContent) {
                markdown += `**LinkedIn Post:**\n\n`;
                markdown += `\`\`\`\n${linkedinContent.content}\n\`\`\`\n\n`;
            }

            const twitterContent = achievement.content.find(
                (c: any) => c.format === "twitter_thread"
            );
            if (twitterContent) {
                markdown += `**Twitter Thread:**\n\n`;
                markdown += `\`\`\`\n${twitterContent.content}\n\`\`\`\n\n`;
            }

            markdown += `---\n\n`;
        }

        // Create response with file download headers
        return new NextResponse(markdown, {
            headers: {
                "Content-Type": "text/markdown",
                "Content-Disposition": `attachment; filename="gitxflow-achievements-${new Date()
                    .toISOString()
                    .split("T")[0]}.md"`,
            },
        });
    } catch (error) {
        console.error("Export error:", error);
        return NextResponse.json(
            { error: "Failed to export achievements" },
            { status: 500 }
        );
    }
}
